{"CourseInfo":{"Title":"Algoritmalar ve Programlama: Kavramlardan Çizge Algoritmalarına","Description":"Bu eğitim, algoritma kavramını, algoritma türlerini, veri yapılarının mantığını ve karşılaştırmalarını, ağaçlar ile özetleme tabloları dahil olmak üzere ileri düzey yapıların avantajlarını, problem çözmeden analiz ve karmaşıklık hesaplamalarına kadar algoritma tasarım süreçlerini, temel arama ve sıralama algoritmalarını ve çizge kuramının algoritmalarını sistematik ve örneklerle açıklar.","Objective":null,"TargetAudience":null,"CourseImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","AudioDuration":5,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-ai-CourseCoverSpeech-bfa3aef0-9024-4d45-a852-5812837dfcfa.mp3","SpeechFileName":"1-ai-CourseCoverSpeech-bfa3aef0-9024-4d45-a852-5812837dfcfa.mp3"},"Sections":[{"PageStyle":26,"YoutubeSearchKeyword":null,"Index":1,"Title":"Algoritmalar ve Programlama: Eğitimin Amacı ve Genel Bakış","Description":null,"Content":{"paragraph":"Bu eğitimde algoritmanın ve programlamanın temel kavramları sistematik biçimde işlenecektir; Algoritma Türleri Ve Veri Yapıları Mantığıyla Karşılaştırma; Ağaçlar Ve Özetleme Tabloları Gibi İleri Düzey Yapıların Avantajları; Problemi Analiz Etme Ve Karmaşıklık Hesaplama Yöntemleri; Temel Arama Ve Sıralama Algoritmaları; Çizge Teorisi Algoritmaları Sistematik Açıklamalar; Bilgi Ve Uygulama Becerisi Kazandırılması Hedeflenir."},"NarrationText":"Bu eğitimde, algoritmanın temel kavramı, algoritma türlerinin ve veri yapıların mantığı ile karşılaştırması, ağaçlar ve özetleme tabloları gibi ileri düzey yapıların avantajları, problem çözmeden analiz ve karmaşıklık hesaplamalarına kadar algoritma tasarım süreçleri kapsamlı olarak ele alınacaktır. Ayrıca temel arama, sıralama algoritmaları ile çizge teorisinin algoritmaları örneklerle ve sistematik biçimde açıklanmaktadır. Amaç, algoritma ve programlama konularında bilgi ve uygulama becerisi kazandırmaktır.","Images":[],"YoutubeUrl":null,"AudioDuration":32,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_1_fed122d6-bd76-4b2e-831e-5f5e8fe50e91.mp3","SpeechFileName":"AI_Section_1_fed122d6-bd76-4b2e-831e-5f5e8fe50e91.mp3","RelevantDocumentPart":null},{"PageStyle":27,"YoutubeSearchKeyword":null,"Index":2,"Title":"Algoritma Kavramı: Tanım ve Günlük Hayattan Örnekler","Description":null,"Content":{"paragraph":"Algoritma, Açıkça Belirlenmiş Adımlar Kümesidir ve programlamanın temel taşını oluşturur.","subtext1":"Yemek Tarifi, Yol Tarifi, Cihaz Kullanma Kılavuzu","subtext2":"ATM'den Para Çekme: İş Tanımı ve Takip Edilecek Adımlar"},"NarrationText":"Algoritma, bir işin nasıl yapılacağını açıkça belirten adımlar kümesidir. Programlamanın temel unsuru olan algoritmalar, günlük hayatın her anında karşımıza çıkar: bir yemek tarifi, yol tarifi ya da cihaz kullanma kılavuzu hep birer algoritmadır. ATM’den para çekme gibi gerçek hayattaki işlemler, adım adım takip edilmesi gereken açık talimatlara dayanır ve algoritmanın temel yapı taşlarını oluşturur: iş tanımı ve izlenmesi gereken işlemler listesi.","Images":[{"ImagePrompt":"People using an ATM, cooking in a kitchen, reading device manual, illustration showing step by step instructions","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":30,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_2_95ca2784-5433-4f6f-af6a-5556297d3651.mp3","SpeechFileName":"AI_Section_2_95ca2784-5433-4f6f-af6a-5556297d3651.mp3","RelevantDocumentPart":null},{"PageStyle":15,"YoutubeSearchKeyword":null,"Index":3,"Title":"Algoritmaların Temel Özellikleri","Description":null,"Content":{"paragraph":"Her algoritmanın verimli ve güvenilir olması için bazı temel özellikleri olmalıdır.","list":"Girdi Ve Çıktı Mutlaka Tanımlanmalıdır; Adımlar Açık Ve Doğru Olmalı, Her Girdi İçin Doğru Sonuç Vermelidir; Sonluluk, Verimlilik Ve Genellik Prensipleri"},"NarrationText":"Bir algoritmanın etkinliği, sahip olduğu bazı temel özelliklere bağlıdır. Her algoritmada dışarıdan girilen veri yani girdi ve algoritmanın ürettiği çıktı bulunur. Adımlar açıklık ve doğrulukla tanımlanmalı; algoritma her girdi için doğru sonuç vermelidir. Sonluluk prensibi gereği algoritmanın bir sonu olmalıdır, sonsuz döngüye girmemelidir. Verimlilik için makul sürede tamamlanmalı; genellik ise benzer problemlere de uygulanabilmelidir. Verimli algoritmalar, programların da performansını belirler.","Images":[{"ImagePrompt":"Flowchart with input and output points, highlighted end point, efficient process arrows, algorithm concept visual","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":34,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_3_44421118-dd46-4401-8344-a2c689080ed1.mp3","SpeechFileName":"AI_Section_3_44421118-dd46-4401-8344-a2c689080ed1.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":4,"Title":"Algoritma Gösterim Yöntemleri: Konuşma Dili ile Gösterim","Description":null,"Content":{"paragraph1":"Algoritmalar konuşma diliyle net ve sıralı şekilde anlatılıp günlük yaşama uygun şekilde ifade edilir.","paragraph2":"Euclid Algoritması Gibi Yöntemler, Adım Adım Mantığın Şeffaf Aktarımı İçin Konuşma Diliyle Gösterilir."},"NarrationText":"Farklı algoritmalar genellikle konuşma dili, akış şeması ve sözde kod kullanılarak gösterilir. Konuşma dilinde, algoritmanın açıklaması ve adımları net biçimde, günlük anlatım kurallarıyla liste halinde sunulur. Örneğin, iki tam sayının ortak bölenlerinin en büyüğünü bulan Euclid algoritması, adım adım işlemlerin nasıl ilerleyeceğini kolay anlaşılacak şekilde açıklar. Bu yöntem, algoritmanın mantığını sıralı ve şeffaf olarak ortaya koyar.","Images":[{"ImagePrompt":"Illustration of algorithm steps written in plain language, Euclid algorithm example, list format explanation, classroom setting","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":29,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_4_b8e4b154-4827-46fa-8221-6c22716f8983.mp3","SpeechFileName":"AI_Section_4_b8e4b154-4827-46fa-8221-6c22716f8983.mp3","RelevantDocumentPart":null},{"PageStyle":17,"YoutubeSearchKeyword":null,"Index":5,"Title":"Akış Şeması ve Sözde Kod ile Gösterim","Description":null,"Content":{"paragraph":"Algoritmaları görsel akış şemaları ve sözde kod ile göstermek kolay kavranmayı sağlar.","subtitle":"Akış Şeması Ve Sözde Kod","subtext1":"Kutucuklar, Oklar, Karar Noktaları İle Adımlar Arası Geçiş","subtext2":"Programlamaya Yakın Sade Anlatım"},"NarrationText":"Algoritmalar görsel olarak akış şemasıyla gösterilebilir; burada kutucuklar, oklar ve karar noktaları arasında adım adım geçişler izlenir, bu da anlaşılmayı kolaylaştırır. Sözde kod ise, doğal dil ile programlama dili arasında bir geçiş sunar, adımlar programlamaya yakın bir mantıkla ve sade bir biçimde açıklanır. Böylece algoritmanın yapısı, hem yeni başlayanlar hem de deneyimli programcılar tarafından kolayca kavranabilir.","Images":[{"ImagePrompt":"Simple flowchart diagram with labeled steps and arrows, blocks containing pseudo code examples, easy to understand style","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_5_bbd1622e-062f-43cc-9535-c21652453274.mp3","SpeechFileName":"AI_Section_5_bbd1622e-062f-43cc-9535-c21652453274.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":6,"Title":"Algoritma Türleri ve Sınıflandırılması: Temel Yaklaşımlar","Description":null,"Content":{"list":"Özyinelemeli Algoritmalar: Problemi Parçalara Bölme; Geri İzlemeli Algoritmalar: Her Olasılığı Deneme; Böl Ve Yönet, Dinamik Programlama; Açgözlü Ve Kaba Kuvvet Algoritmaları"},"NarrationText":"Algoritmalar, problemi çözme yöntemlerine göre sınıflandırılır. Özyinelemeli algoritmalar, problemi küçük parçalara bölüp çözümlerini birleştirir. Geri izlemeli algoritmalar tüm olasılıkları dener ve gerekirse geriye döner. Böl ve yönet algoritmaları, problemi alt problemlere ayırıp, özyineleme ile birleştirir. Dinamik programlama daha önce çözülen alt problemleri kaydeder. Açgözlü algoritmalar, her adımda yerel olarak en iyi seçimi yapar. Kaba kuvvet algoritmaları ise tüm olasılıkları sırayla dener, genellikle en basit ama en yavaş çözümlerdir.","Images":[{"ImagePrompt":"Categorized algorithm types, recursion tree, flowchart showing backtracking, greedy and brute force paths, educational infographic","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":38,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_6_c48dd9a1-05e9-456b-8ef8-cc60c71060ee.mp3","SpeechFileName":"AI_Section_6_c48dd9a1-05e9-456b-8ef8-cc60c71060ee.mp3","RelevantDocumentPart":null},{"PageStyle":6,"YoutubeSearchKeyword":null,"Index":7,"Title":"Temel Veri Yapıları: Dizi (Array) Kavramı","Description":null,"Content":{"title":"Temel Veri Yapıları: Dizi (Array) Kavramı","bullet1":"Aynı Tipteki Veriler Bir Arada","bullet2":"Sabit Uzunlukta Yapı","bullet3":"Her Elemanda Bir İndis Bulunur","bullet4":"Hızlı Erişim İmkânı","bullet5":"Tek ve Çok Boyutlu Diziler","bullet6":"Tablo Benzeri Yapı: İki Boyutlu Dizi"},"NarrationText":"Dizi, aynı tipteki verileri sabit uzunlukta bir yapı olarak bir arada tutar. Her verinin dizi içinde bir indisi bulunur ve elemanlara bu indislerle hızlıca erişim sağlanır. Diziler tek veya çok boyutlu olabilir; örneğin iki boyutlu diziler satır ve sütunlardan oluşan tablolara benzer. Dizi yapısında uzunluk sabittir ve oluşturulurken belirlenir. Bu özellik, elemanlara doğrudan ve hızlı erişim imkanı sağlar.","Images":[{"ImagePrompt":"A simple horizontal array of colored squares, each labeled with an index number, visualizing fixed length and direct access","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null},{"ImagePrompt":"A grid table illustration showing a two-dimensional array with rows and columns labeled, filled with numbers","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":29,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_7_2bc91789-071d-4575-9bcd-0a21aaee366c.mp3","SpeechFileName":"AI_Section_7_2bc91789-071d-4575-9bcd-0a21aaee366c.mp3","RelevantDocumentPart":null},{"PageStyle":1,"YoutubeSearchKeyword":null,"Index":8,"Title":"Bağlı Listeler: Kavramı ve Farkları","Description":null,"Content":{"title":"Bağlı Listeler: Kavramı ve Farkları","bullet1":"Nesneler Düğüm ve Göstericilerle Bağlanır","bullet2":"Her Düğümde Veri ve Sonraki Düğümü Gösteren İşaretçi","bullet3":"Dinamik Uzunluk","bullet4":"Kolay Ekleme ve Silme","bullet5":"Doğrudan Erişim Yok; Elemanlar Sıralı Aranır","bullet6":"Tek Yönlü, Çift Yönlü ve Dairesel Türler"},"NarrationText":"Bağlı liste, aynı türden nesnelerin doğrusal sırada, düğüm ve göstericilerle birbirine bağlandığı bir veri yapısıdır. Her düğümde veri ve bir sonraki düğüme işaret eden gösterici bulunur. Bağlı listelerin uzunluğu dinamiktir; yeni düğümler kolayca eklenip çıkarılabilir. Veri ekleme-silme dizilere göre daha kolaydır ancak doğrudan erişim yoktur; elemanlar sırayla aranır. Bağlı listeler tek yönlü, çift yönlü ve dairesel gibi farklı türlerde olabilir.","Images":[{"ImagePrompt":"A linked list diagram with several nodes connected by arrows, each node showing data and a next pointer","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":31,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_8_2f0f7c8e-6983-44a7-a495-a32cdbb662b9.mp3","SpeechFileName":"AI_Section_8_2f0f7c8e-6983-44a7-a495-a32cdbb662b9.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":9,"Title":"Kuyruk: Temel Mantık ve Özellikler","Description":null,"Content":{"title":"Kuyruk: Temel Mantık ve Özellikler","bullet1":"FIFO: İlk Giren İlk Çıkar Prensibi","bullet2":"Baş (Front) ve Son (Rear) Takibi","bullet3":"Veriler Sona Eklenir, Baştan Çıkarılır","bullet4":"Bankada Veya Kasada Sıra Mantığı","bullet5":"Dizi veya Bağlı Liste İle Programlama","bullet6":"Ekleme (Enqueue) ve Çıkarma (Dequeue) İşlemleri"},"NarrationText":"Kuyruk, verilerin doğrusal bir sırada tutulduğu ve işlemlerin FIFO (ilk giren ilk çıkar) prensibine göre yapıldığı bir veri yapısıdır. Kuyruğun başı (front) ve sonu (rear) vardır. Veriler son tarafa eklenir, baştan çıkarılır. Bankalarda veya market kasalarında karşılaşılan sıra mantığıyla benzer çalışır. Kuyruklar diziler veya bağlı listeler ile programlanabilir; baş ve sonun takibi önemlidir. Kuyrukta ekleme (enqueue) ve çıkarma (dequeue) temel işlemlerdir.","Images":[{"ImagePrompt":"Queue data structure illustrated as a row of people waiting in line, with arrows showing enqueue at rear and dequeue at front","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":34,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_9_ff6797b6-7458-4afd-bd91-252760da293a.mp3","SpeechFileName":"AI_Section_9_ff6797b6-7458-4afd-bd91-252760da293a.mp3","RelevantDocumentPart":null},{"PageStyle":21,"YoutubeSearchKeyword":null,"Index":10,"Title":"Yığın: Temel Mantık ve Çalışma Prensibi","Description":null,"Content":{"title":"Yığın: Temel Mantık ve Çalışma Prensibi","bullet1":"LIFO: Son Giren İlk Çıkar","bullet2":"Veriler Üst Üste Dizilir","bullet3":"Tepe (Top) Noktasından İşlem","bullet4":"Tabak Yığını Örneği","bullet5":"Diziyle veya Bağlı Listeyle Uygulanabilir","bullet6":"Push, Pop, Peek İşlemleri"},"NarrationText":"Yığın, verilerin üst üste dizildiği, ekleme ve çıkarma işlemlerinin yalnızca en üstten gerçekleştiği bir veri yapısıdır. LIFO (son giren ilk çıkar) mantığı ile çalışır. Yığının tepe (top) noktası vardır; yeni elemanlar en üste eklenir, en üstekiler ilk çıkar. Üniversite yemekhanesindeki tabaklar buna örnek verilebilir. Dizilerle veya bağlı listelerle yığın uygulamaları yapılabilir. Temel işlemler push (ekle), pop (çıkar) ve peek (en üst elemanı gör) işlemleridir.","Images":[{"ImagePrompt":"Stack data structure illustrated as a vertical pile of colored plates, push and pop arrows shown at the top","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":34,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_10_2573dac3-8ff5-46eb-b2af-bcc07d9b1c8d.mp3","SpeechFileName":"AI_Section_10_2573dac3-8ff5-46eb-b2af-bcc07d9b1c8d.mp3","RelevantDocumentPart":null},{"PageStyle":25,"YoutubeSearchKeyword":null,"Index":12,"Title":"Diziler, Bağlı Listeler, Kuyruklar ve Yığınlar Üzerinde Uygulamalar","Description":null,"Content":{"title":"Diziler, Bağlı Listeler, Kuyruklar ve Yığınlar Üzerinde Uygulamalar","bullet1":"Dizilerde Elemanlara İndislerle Erişim","bullet2":"Bağlı Listelerde Düğüm Oluşturma, Ekleme, Çıkarma","bullet3":"Kuyrukta Baş ve Sonun Takibi","bullet4":"Yığında Tepe (Top) Yönetimi","bullet5":"Farklı Avantajlar ve Uygulama Kolaylıkları","subtitle":"Uygulama Kolaylıkları","subtext":"Her Veri Yapısı Kendi Avantajlarını Sunar"},"NarrationText":"Tek ve çok boyutlu dizilerde elemanlara indislerle erişilir. Bağlı listelerde düğüm oluşturma, ekleme, çıkarma ve gezinme gibi temel işlemler uygulanabilir. Kuyruklar dizi veya bağlı liste ile programlanır; baş (front) ve son (rear) izlenir. Yığınlar da benzer şekilde dizi veya bağlı listeyle yapılabilir; tepe (top) değişkeni ile yönetilir. Her veri yapısı, farklı avantajlar ve uygulama kolaylıkları sunar.","Images":[{"ImagePrompt":"Split illustration: array grid, linked list nodes, queue row, stack plates, all highlighted for data structure comparison","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":30,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_12_1ee812e4-3f06-45bd-b010-bc8d7ff1709f.mp3","SpeechFileName":"AI_Section_12_1ee812e4-3f06-45bd-b010-bc8d7ff1709f.mp3","RelevantDocumentPart":null},{"PageStyle":21,"YoutubeSearchKeyword":null,"Index":13,"Title":"Ağaçlar ve Temel Ağaç Yapıları","Description":null,"Content":{"title":"Ağaçlar ve Temel Ağaç Yapıları","bullet1":"Düğümler ve Bunları Bağlayan Dallar","bullet2":"Kök, Dal, Yol, Ebeveyn ve Çocuk Kavramları","bullet3":"Ağaç Yüksekliği ve Düğüm Derinliği","bullet4":"İkili Ağaç: En Fazla İki Çocuk","bullet5":"İkili Arama Ağacı: Sol Küçük, Sağ Büyük Değer","bullet6":"Hiyerarşik Veri Modeli ile Düzen ve Hızlı Erişim"},"NarrationText":"Ağaç, düğümler ve bunları bağlayan dallardan oluşan hiyerarşik bir veri modelidir. Kök (root), dal (edge), yol (path), ebeveyn (parent), çocuk (child), ağaç yüksekliği ve düğüm derinliği temel kavramları oluşturur. İkili ağaçlarda her düğüm en fazla iki çocuk içerebilir. İkili arama ağaçlarında ise sol alt ağaçtaki değerler küçük, sağ alt ağaçtaki değerler büyük veya eşit olur. Bu yapılar, karmaşık verilere hızlı erişim ve düzen sağlar.","Images":[{"ImagePrompt":"Simple binary tree diagram with root, parent, children and edges labeled, showing hierarchical data structure","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":33,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_13_e08311a3-cc24-4e3b-893c-2d2139d8424a.mp3","SpeechFileName":"AI_Section_13_e08311a3-cc24-4e3b-893c-2d2139d8424a.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":14,"Title":"Ağaçlarda Gezinme ve AVL Ağaçları","Description":null,"Content":{"list":"Üç Temel Gezinme Yöntemi: Preorder, Inorder, Postorder; Ağaçta Arama ve Yazdırma İçin Kullanılır; AVL Ağaçlarında Denge Farkı En Fazla 1 Olmalıdır; Denge Bozulunca LL, RR, LR, RL Döndürme Uygulanır"},"NarrationText":"İkili ağaçlarda düğümler üzerinde gezinme için üç temel yöntem kullanılır: Preorder (kök başta), Inorder (kök ortada) ve Postorder (kök sonda). Bu yöntemlerle ağaçta arama veya düğüm değerlerini yazdırma işlemleri yapılabilir. AVL ağaçlarında ise denge korunur; sol ve sağ alt ağaçların yükseklik farkı en fazla 1 olur. Denge bozulduğunda LL, RR, LR, RL döndürme işlemleri uygulanarak ağaç yeniden dengelenir.","Images":[{"ImagePrompt":"Diagram of binary tree with preorder, inorder, and postorder traversal highlighted; beside an AVL tree showing rotations; visually demonstrates balancing rotations","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":30,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_14_cec6484f-37a2-4da3-9fe9-2c0c5003f68f.mp3","SpeechFileName":"AI_Section_14_cec6484f-37a2-4da3-9fe9-2c0c5003f68f.mp3","RelevantDocumentPart":null},{"PageStyle":17,"YoutubeSearchKeyword":null,"Index":15,"Title":"Yığın Ağaçları ve Özellikleri","Description":null,"Content":{"paragraph":"Yığın ağaçları, küçük değeri hızlı bulmak için tasarlanır. Her düğümde heap özelliği: değeri, çocuklarından küçük veya eşit olmalıdır. Düzeyler doludur, fakat en sağda eksik eleman olabilir. Diziler ile gösterilir ve işlemler hızlıdır.","subtitle":"Yığın Ağacı Özellikleri","subtext1":"Her Düğüm Heap Özelliğine Sahip Olmalı","subtext2":"En Küçük Elemanı Bulma ve Çıkarma Etkilidir"},"NarrationText":"Yığın ağaçları, veri kümesindeki en küçük elemanın hızlıca bulunmasını sağlayan, özel bir ikili ağaç türüdür. Yığın ağacında, her düğümün değeri çocuklarının değerlerinden küçük veya eşit olmalıdır (heap özelliği). Ağaç bütünlüğü ile son düzeye kadar dolu olmalı, en sağda eksik eleman olabilir. Yığın ağaçları genellikle dizilerle gösterilir ve işlemler hızlı gerçekleşir. En küçük elemanın bulunması ve çıkarılması etkilidir.","Images":[{"ImagePrompt":"Illustration of a min-heap binary tree, nodes showing parent smaller than children; array representation of a heap; labeled nodes indicating heap property","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_15_5767b83d-cdff-4f5d-a9c2-6b8b35191bb3.mp3","SpeechFileName":"AI_Section_15_5767b83d-cdff-4f5d-a9c2-6b8b35191bb3.mp3","RelevantDocumentPart":null},{"PageStyle":25,"YoutubeSearchKeyword":null,"Index":16,"Title":"Yığın Ağaçlarında Ekleme ve Çıkarma İşlemleri","Description":null,"Content":{"paragraph":"Yığın ağaçlarında eklemede düğüm en alta eklenir ve yukarı yönlendirme ile doğru yere taşınır. En küçük eleman çıkarılınca kökle son düğüm yer değiştirir ve aşağı yönlendirme ile doğru konumuna iner. Bu sayede veri bütünlüğü ve heap özelliği korunur.","subtitle":"Ekleme ve Çıkarma İşlemleri","subtext":"Düğüm Yer Değiştirme ile Heap Düzeni Sağlanır"},"NarrationText":"Yığın ağaçlarında, yeni eleman eklenirken ağacın en altına eklenen düğüm, gerekirse ebeveyniyle yer değiştirilerek yukarı yönlendirme ile doğru yere taşınır. En küçük elemanı çıkarmak için ise kökle en alttaki düğüm yer değiştirir, sonra bu eleman aşağı yönlendirme ile doğru konuma iner. Bu şekilde hem veri bütünlüğü hem de heap özelliği korunur. Böylece ekleme ve çıkarma işlemleri hızlı ve dengeli yapılabilir.","Images":[{"ImagePrompt":"Process diagrams for min-heap insert and remove operations; arrows showing up-heap and down-heap rotations; tree visually changing structure","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_16_0b29e246-8c2f-4e63-a88c-c95cfca29bed.mp3","SpeechFileName":"AI_Section_16_0b29e246-8c2f-4e63-a88c-c95cfca29bed.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":17,"Title":"Özetleme (Hash) Tabloları: Temeller","Description":null,"Content":{"paragraph1":"Özetleme (hash) tabloları anahtar-değer çiftleriyle hızlı arama, ekleme ve silme işlemleri sağlar. Her veri, bir hash fonksiyonuyla kendine özgü bir indekse yerleştirilir. Büyük veri kümelerinde etkin erişim sunar.","paragraph2":"Tablonun amacı veriyi eşit ve hızlı erişilen alanlara dağıtmaktır; anahtarlar sayısal veya harf dizileriyle olabilir."},"NarrationText":"Özetleme (hash) tabloları, verileri anahtar-değer çiftleriyle saklayan ve hızlı arama, ekleme, silme imkânı sunan bir veri yapısıdır. Her veri, hash fonksiyonu ile tabloya özgü bir indise yerleştirilir. Sayısal anahtar veya dizgi anahtarla kullanılabilir. Fonksiyonun amacı, verileri eşit ve hızlı erişilen alanlara dağıtmaktır. Bu sayede büyük veri kümelerinde bile istenen bilgiye çok daha kısa sürede ulaşılır.","Images":[{"ImagePrompt":"Modern hash table illustration; boxes as cells, key-value pairs mapped by hashing function; arrows showing mapping process","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_17_fb99dddb-20d4-4717-b524-22db2d91870b.mp3","SpeechFileName":"AI_Section_17_fb99dddb-20d4-4717-b524-22db2d91870b.mp3","RelevantDocumentPart":null},{"PageStyle":25,"YoutubeSearchKeyword":null,"Index":18,"Title":"Hash Fonksiyonları ve Çatışma Kavramı","Description":null,"Content":{"paragraph":"Hash fonksiyonları bazen farklı anahtarları aynı indise yerleştirir; buna çatışma (collision) denir. Çatışma ihtimali azaltılmalı, çözümde zincirleme veya açık adresleme yöntemleri kullanılmalıdır.","subtitle":"Çatışma Çözüm Yöntemleri","subtext":"Ayrık Zincirleme ve Açık Adresleme ile Performans Korunur"},"NarrationText":"Hash fonksiyonları, verileri tabloya yerleştirirken bazı anahtarlar aynı indise düşebilir; bu duruma çatışma (collision) denir. Etkin bir hash fonksiyonu, çatışma ihtimalini azaltmalı ve işlemleri hızlı yapmalıdır. Çatışma kaçınılmazsa, tablo yapısında ayrık zincirleme (bağlı liste ile birden çok veri saklama) veya açık adresleme (boş başka indis bulma) gibi yöntemlerle çözüm geliştirilir. Böylece hash tablo performansı korunur.","Images":[{"ImagePrompt":"Visualization of hash table with collisions; linked list for chaining, probing for open addressing; arrows show resolving collision","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":30,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_18_b5955e5e-a349-45fa-a6df-2d6d577e7d34.mp3","SpeechFileName":"AI_Section_18_b5955e5e-a349-45fa-a6df-2d6d577e7d34.mp3","RelevantDocumentPart":null},{"PageStyle":30,"YoutubeSearchKeyword":null,"Index":19,"Title":"Hash Tablolarında Ayrık Zincirleme ve Açık Adresleme Yöntemleri","Description":null,"Content":{"list":"Ayrık Zincirleme: Aynı İndiste Birden Fazla Veri Bağlı Listeyle Saklanır; Açık Adresleme: Çakışmada Farklı Alan Aranır, Doğrusal veya Karesel Sınama Kullanılır"},"NarrationText":"Ayrık zincirleme yönteminde, aynı indis değerine sahip veriler bir bağlı listeyle saklanır. Bu sayede bir indiste birden fazla veri tutulabilir. Açık adreslemede ise, anahtar değeriyle çakışma olduğunda farklı bir hash fonksiyonu veya sınama yöntemiyle tablodaki başka bir boş alan aranır. Doğrusal, karesel sınama veya ikili hash teknikleriyle çatışma çözülebilir. Bu yöntemler hash tablolarında hızlı arama ve güncelleme sağlar.","Images":[{"ImagePrompt":"Split screen comparison: on left, hash table with linked list chaining at same index; on right, hash table using open addressing techniques (linear, quadratic probes); clear method differences","ImageSize":"W1792xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":30,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_19_b3e9d856-850e-4bbd-8465-d4de831a3530.mp3","SpeechFileName":"AI_Section_19_b3e9d856-850e-4bbd-8465-d4de831a3530.mp3","RelevantDocumentPart":null},{"PageStyle":32,"YoutubeSearchKeyword":null,"Index":20,"Title":"Algoritma Tasarımı ve Problem Çözme Süreci","Description":null,"Content":{"title":"Algoritma Tasarımı ve Problem Çözme Süreci","paragraph":"Algoritma ile problem çözmeye başlarken, önce problemin ayrıntıları ve donanım özellikleri değerlendirilir. Veri yapıları, programlama dili, algoritmanın gösterim şekli ve doğruluk analizi tasarımın temel adımlarını oluşturur.","list":"Problemin Tüm Ayrıntılarını Anlamak Ve Değerlendirmek; Algoritmanın Doğruluğu Ve Analizi Kodlama Öncesinde Yapılır"},"NarrationText":"Bir problemi algoritma ile çözmeye başlarken öncelikle problemin tüm ayrıntılarını anlamak gerekir. Sonra, kullanılacak bilgisayarın ve donanımın özellikleri değerlendirilir. Veri yapıları seçimi, programlama dili tercihi, algoritmanın konuşma dili, sözde kod veya akış diyagramıyla gösterimi tasarım sürecinin önemli adımlarıdır. Tasarlanan algoritmanın doğruluğu kanıtlanmalı ve analiz çalışmaları kodlama öncesinde tamamlanmalıdır.","Images":[{"ImagePrompt":"Computer desk with papers, flowcharts and pseudocode notes scattered, person analyzing structure","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null},{"ImagePrompt":"Close-up of hands choosing between different programming languages and data structures on monitor","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_20_9ff68468-25d4-4633-b1b2-3010f8b4c6a1.mp3","SpeechFileName":"AI_Section_20_9ff68468-25d4-4633-b1b2-3010f8b4c6a1.mp3","RelevantDocumentPart":null},{"PageStyle":8,"YoutubeSearchKeyword":null,"Index":21,"Title":"Döngü-Tekrarlama Yöntemiyle Algoritma Tasarımı","Description":null,"Content":{"paragraph1":"Döngü algoritmaları, işlemleri veri dizileri üzerinde tekrarlayarak problemleri çözer. Bu algoritmalar toplama, gezme veya karşılaştırma gibi aşamalarda veri üzerinde doğrusal hareket sağlar.","paragraph2":"Her bir eleman sırasıyla kontrol edilerek güncellenir; bu yöntem veri üzerinde yineleme gerektiren problemlerin temel çözüm yöntemidir."},"NarrationText":"Döngü algoritmaları, bir dizi üzerinde gezme, toplama veya en büyük elemanı bulma gibi işlemler için tekrar eden yapılar sunar. Örneğin, dizi içindeki en büyük elemanı bulmak için, her eleman sırayla kontrol edilir ve mevcut en büyük değer güncellenir. Döngü algoritmaları, sıkça veri üzerinde yineleme gerektiren problemlerin çözümünde temel yaklaşım olarak kullanılır ve programda doğrusal hareket sağlar.","Images":[{"ImagePrompt":"Code on computer screen showing a loop iterating over an array, highlighting largest value found","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":26,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_21_fff6432e-8546-4c21-81bf-ce11282a3985.mp3","SpeechFileName":"AI_Section_21_fff6432e-8546-4c21-81bf-ce11282a3985.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":22,"Title":"Küçült-Fethet (Decrease &amp; Conquer) Yöntemi","Description":null,"Content":{"paragraph1":"Küçült-Fethet algoritmalarında, problem daha küçük parçalara bölünerek çözülür. Her aşamada elemanlar uygun pozisyona yerleştirilir ve bir alt problemin çözümünden yararlanılır. Özellikle araya sokma sıralama gibi algoritmalarda bu yaklaşım etkin şekilde uygulanır.","paragraph2":"Yöntem döngü ile veya özyineleme ile yürütülebilir; problem çözümü adım adım küçültülerek ve alt parçalardan faydalanılarak yapılır."},"NarrationText":"Küçült-Fethet yönteminde, problemin çözümüyle daha küçük bir alt problemin çözümü arasında bağlantı kurulur. Örneğin, araya sokma sıralama algoritmasında, her adımda bir eleman kendi sırasındaki en uygun pozisyona yerleştirilir. Bu yöntemle, problemler genellikle adım adım küçültülerek ve alt parçalardaki çözümden faydalanılarak sonuç elde edilir. Döngü veya özyineleme ile uygulanabilir.","Images":[{"ImagePrompt":"Visual representation of insertion sort placing each element into its correct position step by step","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":25,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_22_c253bfd1-6839-41fa-a0ca-f1f6466513d1.mp3","SpeechFileName":"AI_Section_22_c253bfd1-6839-41fa-a0ca-f1f6466513d1.mp3","RelevantDocumentPart":null},{"PageStyle":2,"YoutubeSearchKeyword":null,"Index":23,"Title":"Böl-Fethet (Divide &amp; Conquer) Yöntemiyle Algoritma Tasarımı","Description":null,"Content":{"subtitle":"Böl-Fethet Yöntemiyle Algoritma Tasarımı","paragraph1":"Böl-Fethet algoritmasında, problem iki veya daha fazla eşit alt probleme ayrılır. Her alt problem özyinelemeli olarak çözülür ve elde edilen sonuçlar birleştirilir.","paragraph2":"Karmaşık problemleri küçük alt problemlere indirgemek ve çözümlemek amaçlanır; örneğin, sayıların toplamını ikiye bölerek veya özyinelemeyle çözmek bu yönteme örnektir."},"NarrationText":"Böl-Fethet yönteminde problem genellikle iki veya daha fazla eşit alt probleme ayrılır. Her alt problem özyinelemeli olarak çözülür ve alt çözümler birleştirilerek genel sonuç elde edilir. 1’den N’ye kadar sayıların toplamını özyineleme ile çözmek veya dizi toplamını ikiye bölerek hesaplamak bu yönteme örnektir. Temel amaç, karmaşık problemleri daha basit alt problemlere indirgemektir.","Images":[{"ImagePrompt":"Abstract split of main problem into sub-problems using branching tree and recursive arrows","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":26,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_23_9c26c946-7907-44ed-ac2a-9e03deb88bf6.mp3","SpeechFileName":"AI_Section_23_9c26c946-7907-44ed-ac2a-9e03deb88bf6.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":24,"Title":"Özyinelemeli Fonksiyon Algoritmaları","Description":null,"Content":{"paragraph1":"Özyinelemeli fonksiyon algoritmalarında, fonksiyon kendisini çağırarak problemin en küçük parçasından başlayıp tümü için çözüm üretir. Özellikle Fibonacci serisi veya dizi toplamı gibi işlemlerde, en temel durumda doğrudan çözüm belirlenir ve özyineleme ile daha büyük problemlere uygulanır.","paragraph2":"Bu yöntem matematiksel problemlerde ve veri üzerinde tekrar gerektiren işlemlerde oldukça etkilidir."},"NarrationText":"Özyinelemeli fonksiyon algoritmalarında, fonksiyon kendi içinde yine kendisini çağırır. Fibonacci serisinin hesaplanmasında veya bir dizinin özyinelemeli olarak toplanmasında kullanılır. Problemin en küçük parçası için doğrudan bir çözüm belirlenir; ardından özyineleme sayesinde, daha büyük boyuttaki problemler de en küçükten yukarıya doğru çözülür. Bu yaklaşım özellikle matematiksel problemler için yararlıdır.","Images":[{"ImagePrompt":"Fibonacci sequence visualized with recursion tree, showing base and recursive cases highlighted","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":27,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_24_fcbad5cb-9c04-4efa-b9f1-1b8e05d82dd4.mp3","SpeechFileName":"AI_Section_24_fcbad5cb-9c04-4efa-b9f1-1b8e05d82dd4.mp3","RelevantDocumentPart":null},{"PageStyle":9,"YoutubeSearchKeyword":null,"Index":25,"Title":"Algoritma Tasarımında Doğruluk ve Analiz Süreci","Description":null,"Content":{"paragraph":"Algoritma tasarımlarında, doğruluk ve analiz süreci kodlama öncesi aşamada tamamlanır. Tüm olası veriler için doğru sonuç kanıtlanır; ardından karmaşıklık analizi ve kaynak gereksinimleri değerlendirilir.","list":"Algoritmanın Tüm Girişler İçin Doğru Sonuç Verdiği Kanıtlanmalı; Hatalar Yanlış Sonuç Üreten Örnekle Gösterilir; Çalışma Zamanı Ve Bellek Gereksinimi Analiz Edilmeli; Kodlama Son Aşamadır"},"NarrationText":"Bir algoritma tasarlandıktan sonra, tüm girişler için doğru sonuç verdiği mutlaka kanıtlanmalıdır. Hatalı bir algoritmanın yanlış sonucu bir örnekle gösterilebilirken, doğruluğu tüm olası veriler için test gerektirir. Ayrıca algoritmanın çalışma zamanı, karmaşıklık analizi ve bellek gereksinimi incelenmelidir. Analiz süreci tamamlandığında, algoritmanın seçilen programlama dilinde kodlanması son aşamadır.","Images":[{"ImagePrompt":"Flowchart showing analysis steps with correctness, runtime complexity and memory evaluation icons","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":26,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_25_bba4d673-9c4f-4e84-979a-dc15d5679d99.mp3","SpeechFileName":"AI_Section_25_bba4d673-9c4f-4e84-979a-dc15d5679d99.mp3","RelevantDocumentPart":null},{"PageStyle":21,"YoutubeSearchKeyword":null,"Index":26,"Title":"Algoritma Analizi: Amaç ve Temel Kavramlar","Description":null,"Content":{"paragraph1":"Algoritma Analizinin Temel Amacı: Çalışma Zamanı ve Bellek Gereksinimi Belirlenir.","paragraph2":"Farklı Algoritmalar Arasında Karşılaştırmalı Seçim Yapılır.","paragraph3":"Zaman ve Alan Karmaşıklığı, Algoritmaların Değerlendirilmesinde Temel Kriterlerdir."},"NarrationText":"Algoritma analizinin temel amacı, geliştirilmiş bir algoritmanın çalışma zamanı ve bellek gereksinimini belirleyerek, farklı algoritmalar arasında karşılaştırmalı seçim yapmaktır. Her algoritmanın çözüm süresi, bilgisayarın donanımına ve derleyiciye göre değişebilir. Bu yüzden, analizde genellikle temel işlem sayısı ve algoritmadaki önemli adımlar dikkate alınır. Zaman ve alan karmaşıklığı, algoritmaların değerlendirilmesinde temel kriterlerdir.","Images":[{"ImagePrompt":"Conceptual illustration of algorithm analysis, showing time and memory usage comparing different algorithms with abstract icons or charts.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":29,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_26_1d8ee04b-a161-41e6-81c4-373375357f66.mp3","SpeechFileName":"AI_Section_26_1d8ee04b-a161-41e6-81c4-373375357f66.mp3","RelevantDocumentPart":null},{"PageStyle":7,"YoutubeSearchKeyword":null,"Index":27,"Title":"Fonksiyonların Büyümesi ve Zaman Karmaşıklığı","Description":null,"Content":{"paragraph":"Fonksiyonun Giriş Boyutu Artınca Büyüme Şekli İncelenir.; Küçük Verilerde Fark Görülmez, Büyük Veride Etkinlik Önemlidir.; Zaman Karmaşıklığı Sıralama Algoritmalarında Net Fark Yaratır.; Karmaşıklık Notasyonu O(n), O(n^2), O(n log n) Şeklindedir."},"NarrationText":"Tasarlanan algoritmaların etkinliği, giriş boyutu arttıkça fonksiyonun nasıl büyüdüğüne bakarak anlaşılır. Az sayıda veriyle fark gözlenmese de, milyonlarca veri üzerinde yavaş ve hızlı algoritmalar arasındaki fark net olarak ortaya çıkar. Kabarcık sıralaması ve birleştirme sıralaması örneklerinde olduğu gibi, zaman karmaşıklığı düşük olan algoritmalar büyük veri için çok daha verimlidir. Karmaşıklık sınıfı genellikle O(n), O(n^2), O(n log n) gibi notasyonlarla ifade edilir.","Images":[{"ImagePrompt":"Comparison chart showing growth rates of algorithms for different n, with Bubble Sort and Merge Sort curves and O-notation labels.","ImageSize":"W1792xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":32,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_27_99307972-d4a6-4e51-9634-04dfcc865d33.mp3","SpeechFileName":"AI_Section_27_99307972-d4a6-4e51-9634-04dfcc865d33.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":28,"Title":"En İyi, En Kötü ve Ortalama Durum Verimliliği","Description":null,"Content":{"list":"En İyi Durum: Algoritmanın En Hızlı Sonucu Verdiği Durum.; En Kötü Durum: En Uzun Sürede Tamamlanan Durum.; Ortalama Durum: Tüm Olası Girişlerde Ortalama İşlem Süresi.; Performans Karşılaştırmasında Genellikle En Kötü Durum Zemini Alınır."},"NarrationText":"Algoritmalar farklı veri girişlerinde farklı performans gösterebilir. En iyi durumda çalışma, algoritmanın en hızlı sonucu verdiği özel girişler için geçerlidir. En kötü durum ise, algoritmanın en uzun sürede tamamlandığı durumu temsil eder; genellikle analizde bu değerlendirilir. Ortalama durum ise, tüm olası girişler göz önüne alınıp ortalama işlem süresi belirlenir. Bir algoritmanın performansı, çoğunlukla en kötü durum karmaşıklığına göre karşılaştırılır.","Images":[{"ImagePrompt":"Diagram of best, worst, and average case efficiency with visual representations such as stopwatches and different input cases for an algorithm.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":31,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_28_c9b47693-c8ce-43a6-9f9e-cde71275479b.mp3","SpeechFileName":"AI_Section_28_c9b47693-c8ce-43a6-9f9e-cde71275479b.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":29,"Title":"Asimptotik Gösterimler: Büyük O, Ω ve Θ Notasyonları","Description":null,"Content":{"paragraph1":"Algoritmaların Performansı Matematiksel Gösterimlerle Analiz Edilir: Büyük O, Ω ve Θ.","paragraph2":"Büyük O: Üst Sınır, En Hızlı Büyüyen Kısım.; Büyük Ω: Alt Sınır.; Büyük Θ: Tam Sınıfı Tanımlar."},"NarrationText":"Algoritmaların performansı matematiksel olarak büyük O, büyük Ω ve büyük Θ gösterimleriyle analiz edilir. Büyük O gösterimi, algoritmanın üst sınırını belirtir ve en hızlı büyüyen kısmı ifade eder. Büyük Ω gösterimi, alt sınırı tanımlar. Büyük Θ gösterimi ise hem alt hem üst sınırı belirleyerek algoritmanın tam sınıfını tanımlar. Bu gösterimler, algoritmaların doğru şekilde karşılaştırılmasına ve sınıflandırılmasına olanak tanır.","Images":[{"ImagePrompt":"Mathematical symbols O, Omega, and Theta with stylized graphs showing algorithm upper, lower, and tight bounds.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":31,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_29_752c1c37-794b-4f9e-a279-17608637a9f9.mp3","SpeechFileName":"AI_Section_29_752c1c37-794b-4f9e-a279-17608637a9f9.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":30,"Title":"Döngü, İç İçe Döngü ve Karar Yapılarının Analizi","Description":null,"Content":{"paragraph1":"For Döngüsü, İç İçe Döngüler ve If-Else Karar Yapılarının Algoritmaya Etkisi Hesaplanır.","paragraph2":"Basit For Döngüsü O(n), İç İçe Döngüler O(n^2), If-Else'de Zaman Alan Dal Değerlendirilir."},"NarrationText":"Analiz sırasında for döngüsü, iç içe döngüler ve if-else gibi karar yapılarının algoritmaya etkisi hesaplanır. Basit bir for döngüsünün karmaşıklığı O(n) olarak alınırken, iki iç içe döngü O(n^2) olur. Arka arkaya gelen döngülerde ise en büyük karmaşıklık belirleyicidir. If-else yapılarında ise en fazla zaman alan dal değerlendirilir. Bu yöntemlerle algoritmanın işlem adımları ve toplam çalışma süresi net olarak çıkarılır.","Images":[{"ImagePrompt":"Code diagram showing simple loops, nested loops, and if-else blocks with their respective time complexities labeled.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":30,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_30_ad27e21d-462d-4f4e-b720-a36617f4e955.mp3","SpeechFileName":"AI_Section_30_ad27e21d-462d-4f4e-b720-a36617f4e955.mp3","RelevantDocumentPart":null},{"PageStyle":29,"YoutubeSearchKeyword":null,"Index":31,"Title":"Özyinelemeli ve Özyinelemeli Olmayan Algoritmaların Analizi","Description":null,"Content":{"list":"Özyinelemeli Olmayanlarda Temel Operasyonlar Belirlenir.; Özyinelemeli Algoritmalarda Fonksiyonun Rekürsif İlişkisi Kurulur.; Faktöriyel ve Fibonacci Hesaplamaları Tipik Örneklerdir.; Karmaşıklık Sonucu O(n) veya O(log n) Şeklinde İfade Edilir."},"NarrationText":"Algoritmalar özyinelemeli olup olmamasına göre farklı analiz teknikleri gerektirir. Özyinelemeli olmayanlarda temel operasyonlar belirlenir ve toplam adım sayısı matematiksel ifadeyle gösterilir. Özyinelemeli algoritmalarda ise fonksiyonun kendini çağırdığı ilişki yazılır ve çözülür. Örneğin, faktöriyel veya Fibonacci hesaplamaları gibi örneklerde, analiz sonucunda genellikle O(n) veya O(log n) gibi karmaşıklıklar elde edilir. Bu, algoritmanın büyüme hızının anlaşılması açısından önemlidir.","Images":[{"ImagePrompt":"Comparison visual of recursive and non-recursive algorithms, with call stack for recursives and loop steps for non-recursive.","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null},{"ImagePrompt":"Illustration of factorial and Fibonacci tree diagrams representing recursive relations in algorithms.","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":34,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_31_caccc2d5-a223-4721-86b1-17b3c4164ab4.mp3","SpeechFileName":"AI_Section_31_caccc2d5-a223-4721-86b1-17b3c4164ab4.mp3","RelevantDocumentPart":null},{"PageStyle":8,"YoutubeSearchKeyword":null,"Index":32,"Title":"Arama Algoritmaları: Temel Kavramlar ve Genel Bakış","Description":null,"Content":{"paragraph1":"Arama Algoritmaları Veri Yapısında Eleman Bulma İçin Kullanılır","paragraph2":"Algoritma Seçimi Dizinin Sıralı Olup Olmamasına Bağlıdır"},"NarrationText":"Arama algoritmaları, bir dizi veya veri yapısında belirli bir elemanın bulunup bulunmadığını test etmek için kullanılır. Ardışık arama ve ikili arama temel arama yöntemlerindendir. Hangi arama algoritmasının seçileceği, genellikle dizinin sıralı olup olmamasına veya veri yapısının özelliğine bağlıdır. Bu algoritmalar, programlamada hızlı veri bulma ve sorgulamada kritik öneme sahiptir.","Images":[{"ImagePrompt":"An illustration showing various search algorithms in computer science, highlighting a magnifying glass over elements in a data array","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":25,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_32_e978c70b-8ec2-4b41-a3c4-5b2319978abb.mp3","SpeechFileName":"AI_Section_32_e978c70b-8ec2-4b41-a3c4-5b2319978abb.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":33,"Title":"Ardışık Arama: Mantığı ve Uygulama Prensibi","Description":null,"Content":{"list":"En Temel Arama Algoritması ; Tüm Elemanlar Sırayla Kontrol Edilir ; Kurulum Gerektirmez ; Küçük Veri Kümelerinde Tercih Edilir"},"NarrationText":"Ardışık arama, dizinin sıralı olup olmamasına bakılmaksızın tüm elemanları sırayla kontrol eden en temel arama algoritmasıdır. Dizi baştan sona doğru taranır, aranan eleman herhangi bir konumda bulunursa arama sonlandırılır. Eleman dizide yoksa, tüm elemanlar kontrol edilir ve işlem biter. Özellikle küçük veri kümelerinde tercih edilir ve kurulum gerektirmez.","Images":[{"ImagePrompt":"A visual of sequential search, showing a linear scan over an unsorted data array with a highlighted target element","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":24,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_33_3a4edf59-8b33-46b2-81b8-28206b39722c.mp3","SpeechFileName":"AI_Section_33_3a4edf59-8b33-46b2-81b8-28206b39722c.mp3","RelevantDocumentPart":null},{"PageStyle":15,"YoutubeSearchKeyword":null,"Index":34,"Title":"İkili Arama: Sıralı Dizilerde Hızlı Çözüm","Description":null,"Content":{"paragraph":"İkili Arama Sadece Sıralı Dizilerde Kullanılır Ve Her Adımda Alan İkiye Bölünür","list":"Her Adımda Alan İkiye Bölünür ; Büyük Veri Setlerinde Tercih Edilir ; Daha Az Karşılaştırma Yapılır"},"NarrationText":"İkili arama, sadece sıralı dizilerde kullanılabilen verimli bir arama yöntemidir. Dizi ortadan ikiye bölünür, aranan eleman ortadaki değerden büyükse sağa, küçükse sola bakılır. Her adımda arama alanı ikiye bölünerek işlem tekrar edilir. Bu yöntemle arama işlemi, ardışık aramaya göre çok daha az karşılaştırma ile tamamlanır. Büyük veri setlerinde tercih edilen hızlı bir çözümdür.","Images":[{"ImagePrompt":"A diagram of binary search algorithm dividing a sorted array in halves with arrows and highlighted mid-point","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":26,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_34_b963a87c-3036-414f-9729-4a88ab424f6d.mp3","SpeechFileName":"AI_Section_34_b963a87c-3036-414f-9729-4a88ab424f6d.mp3","RelevantDocumentPart":null},{"PageStyle":2,"YoutubeSearchKeyword":null,"Index":35,"Title":"Arama Algoritmalarının Karşılaştırılması","Description":null,"Content":{"subtitle":"Arama Algoritmalarının Karşılaştırılması","paragraph1":"Performans Ve Uygulamada Farklılık Gösterir","paragraph2":"Algoritma Seçimi Verimlilik İçin Kritik Öneme Sahiptir"},"NarrationText":"Arama algoritmaları, performans ve uygulama açısından farklılıklar gösterir. Ardışık aramanın en kötü durumdaki zaman karmaşıklığı O(n) iken, ikili arama O(log n) ile çok daha hızlıdır. Ancak ikili arama sadece sıralı dizilerde kullanılabilir. Dizinin özellikleri ve büyüklüğü, uygun algoritma seçimini etkiler. İyi algoritma seçimi programın genel verimini artırır.","Images":[{"ImagePrompt":"A comparison chart between linear and binary search showing time complexity O(n) vs O(log n)","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":25,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_35_6e169644-a51f-4ce4-8525-d2565757d232.mp3","SpeechFileName":"AI_Section_35_6e169644-a51f-4ce4-8525-d2565757d232.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":36,"Title":"Arama Algoritmalarında Uygulama ve Uyum","Description":null,"Content":{"list":"Ardışık Arama Tüm Dizilerde Çalışır ; İkili Arama Sıralı Dizi Gerektirir ; Algoritma Seçimi Veri Yapısına Bağlıdır ; Uygun Yöntemle Hızlı Ve Doğru Sonuç Alınır"},"NarrationText":"Bir veri yapısında arama yaparken kullanılacak algoritma, verinin sıralı olup olmamasına göre değişir. Ardışık arama, sıralı-sırasız tüm dizilerde çalışırken, ikili arama sıralı dizi gerektirir. Arama işleminin doğru ve hızlı yapılması için dizinin durumu tespit edilmeli ve uygun algoritma ile işlem başlatılmalıdır. Bu yüzden programcı, arama koşullarına göre doğru tercihi yapmalıdır.","Images":[{"ImagePrompt":"An educational scene showing a programmer choosing search algorithms based on an array’s sorted or unsorted status","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":25,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_36_6eef9f81-4329-4bd5-ad06-0bd68756738d.mp3","SpeechFileName":"AI_Section_36_6eef9f81-4329-4bd5-ad06-0bd68756738d.mp3","RelevantDocumentPart":null},{"PageStyle":21,"YoutubeSearchKeyword":null,"Index":37,"Title":"Arama Algoritmalarında Kodlama ve Zaman Karmaşıklığı","Description":null,"Content":{"paragraph1":"Ardışık Ve İkili Aramanın Kodlaması Temel Akış Kontrolüyle Kolayca Yapılır","paragraph2":"Büyük Veri Üzerinde Hızlı Sonuç İçin İkili Arama Tercih Edilir","paragraph3":"Zaman Karmaşıklığı Seçimi Uygulamanın Hızını Belirler"},"NarrationText":"Ardışık ve ikili aramanın kodlaması oldukça basittir ve temel akış kontrolü ile gerçekleştirilebilir. Ardışık aramada her eleman kontrol edilirken, ikili aramada alan her adımda ikiye bölünür. Ardışık aramanın zaman karmaşıklığı O(n), ikili aramanın en kötü durumu O(log n)’dir. Bu nedenlerle büyük veri üzerinde hızlı sonuç almak için ikili arama tercih edilir. Seçilen algoritmanın karmaşıklığı, uygulamanın hızında belirleyicidir.","Images":[{"ImagePrompt":"A split screen showing pseudocode for both linear and binary search algorithms, with time complexity annotations","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":31,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_37_70f2b462-be68-48d2-abb2-9722e0b09528.mp3","SpeechFileName":"AI_Section_37_70f2b462-be68-48d2-abb2-9722e0b09528.mp3","RelevantDocumentPart":null},{"PageStyle":25,"YoutubeSearchKeyword":null,"Index":38,"Title":"Sıralama Algoritmalarına Giriş ve Temel Türler","Description":null,"Content":{"paragraph":"Sıralama, Dizilerin Belirli Bir Düzene Sokulmasıdır. Sayılar Ve Metinler Küçükten Büyüğe Veya Büyükten Küçüğe Sıralanabilir. Temel Algoritmalar: Baloncuk, Seçmeli, Araya Sokarak, Hızlı, Birleştirerek Ve Yığın Sıralaması. Her Algoritmanın Avantajları Ve Dezavantajları Farklıdır.","subtitle":"Temel Sıralama Algoritmaları","subtext":"Baloncuk, Seçmeli, Araya Sokarak, Hızlı, Birleştirerek, Yığın Sıralaması"},"NarrationText":"Sıralama, dizilerin veya veri yapılarının elemanlarını belirli bir düzene sokmak için yapılan işlemdir. Sayılar ya da metinsel ifadeler küçükten büyüğe veya büyükten küçüğe sıralanabilir. Baloncuk, seçmeli, araya sokarak, hızlı, birleştirerek ve yığın sıralaması bu işlemler için en çok kullanılan temel algoritmalardır. Her bir algoritma kendine özgü bir çalışma mantığı, avantajları ve dezavantajları ile öne çıkar.","Images":[{"ImagePrompt":"Illustration showing various sorting algorithms as flowcharts or icons: bubble, selection, insertion, quick, merge, and heap sort; arranged neatly, emphasizing order, with data arrays and arrows.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_38_b8b3548e-b6c4-49fc-af59-e7376b6c00b9.mp3","SpeechFileName":"AI_Section_38_b8b3548e-b6c4-49fc-af59-e7376b6c00b9.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":39,"Title":"Baloncuk ve Seçmeli Sıralama Algoritmaları","Description":null,"Content":{"paragraph1":"Baloncuk Sıralaması: Komşu Elemanları Karşılaştırır Ve Yer Değiştirir; En Büyük Eleman Sona Taşınır, İşlem n-1 Kere Tekrarlanır. Temel Ve Kolay Kodlanabilir. Zaman Karmaşıklığı O(n²).","paragraph2":"Seçmeli Sıralama: Kalan Elemanlardan En Küçüğü Seçilir Ve Uygun Konuma Yerleştirilir. Büyük Veri Setlerinde Yavaştır."},"NarrationText":"Baloncuk sıralaması, her adımda komşu elemanları karşılaştırıp, gerekiyorsa yer değiştirerek en büyük elemanı sona taşır ve n-1 defa tekrarlanır. Seçmeli sıralamada ise, her defasında kalan elemanlar içinden en küçüğü seçilip, sıradaki uygun konuma yerleştirilir. Her iki algoritma da temel ve kolay kodlanabilir olmalarına karşın, büyük veri setlerinde yavaş kalır. Zaman karmaşıklıkları O(n²) düzeyindedir.","Images":[{"ImagePrompt":"Side-by-side visual of bubble sort and selection sort algorithms working on number arrays; highlight element comparisons and swaps, representing slow performance in large data sets.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":27,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_39_8a09996b-71cf-455e-b607-4af0cb2a3000.mp3","SpeechFileName":"AI_Section_39_8a09996b-71cf-455e-b607-4af0cb2a3000.mp3","RelevantDocumentPart":null},{"PageStyle":8,"YoutubeSearchKeyword":null,"Index":40,"Title":"Araya Sokarak ve Hızlı Sıralama","Description":null,"Content":{"paragraph1":"Araya Sokarak Sıralama: Anahtar Eleman Önceki Elemanlarla Karşılaştırılır Ve Uygun Boşluğa Yerleşir.","paragraph2":"Hızlı Sıralama: Pivot Seçilir, Dizi İki Alt Gruba Ayrılır Ve Grup İçinde Sıralama Tekrarlanır. Ortalama Karmaşıklık O(n log n)."},"NarrationText":"Araya sokarak sıralama algoritmasında, dizinden seçilen anahtar eleman kendisinden önce gelenlerle sırasıyla karşılaştırılır, gerektiğinde yer değiştirir ve uygun boşluğa yerleşir. Hızlı sıralamada ise, pivot olarak bir eleman seçilir ve dizi iki alt gruba ayrılır; alt gruplar özyinelemeli olarak tekrar sıralanır. Hızlı sıralama genellikle daha büyük veri setlerinde tercih edilir, çünkü ortalama karmaşıklığı O(n log n)’dir.","Images":[{"ImagePrompt":"Comparative visualization of insertion sort and quicksort; insertion sort shows stepwise comparison and shifting, quicksort highlights partitioning by pivot and recursive sorting, with arrows and array segments.","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_40_d3b38059-430f-4e7a-90ce-be6b794e17e4.mp3","SpeechFileName":"AI_Section_40_d3b38059-430f-4e7a-90ce-be6b794e17e4.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":41,"Title":"Birleştirerek ve Yığın Sıralama Yöntemleri","Description":null,"Content":{"paragraph1":"Birleştirerek Sıralama: Dizi Sürekli Bölünür, Alt Diziler Sıralanır Ve Geçici Dizilerle Yeniden Birleştirilir. Özyinelemeli İlerler.","paragraph2":"Yığın Sıralama: Dizinin Elemanları Yığın Veri Yapısına Düzenlenir Ve En Büyük Eleman Sona Yerleştirilerek Sıralama Yapılır. Her İki Algoritma Büyük Veri İçin Uygundur. Karmaşıklık O(n log n)."},"NarrationText":"Birleştirerek sıralama özyinelemeli ilerler; dizi sürekli bölünür, alt diziler sıralanıp, geçici dizilerle tekrar birleştirilir. Yığın sıralaması ise, dizinin elemanlarını yığın veri yapısı üzerinde düzenler ve ardından teker teker en büyük elemanı sona yerleştirerek sıralama yapar. Her iki algoritma da büyük veri ile çalışmak için uygundur ve zaman karmaşıklığı O(n log n)’dir.","Images":[{"ImagePrompt":"Side-by-side diagram showing merge sort dividing and merging arrays recursively, and heap sort building a heap and extracting largest elements for sorting; highlight efficient handling of big data.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":27,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_41_0d2a4c39-2915-48dc-8d19-f518c6ef7041.mp3","SpeechFileName":"AI_Section_41_0d2a4c39-2915-48dc-8d19-f518c6ef7041.mp3","RelevantDocumentPart":null},{"PageStyle":10,"YoutubeSearchKeyword":null,"Index":42,"Title":"Sıralama Algoritmalarının Özellikleri ve Karşılaştırılması","Description":null,"Content":{"paragraph1":"Sıralama Algoritmaları: Zaman Karmaşıklığı Ve İstikrarlılık Açısından Karşılaştırılır. Baloncuk, Seçmeli, Araya Sokarak Sıralama O(n²). Hızlı, Birleştirerek, Yığın Sıralaması O(n log n).","paragraph2":"İstikrarlı Algoritmalar: Aynı Değerdeki Elemanların Sırasını Korur (Baloncuk, Araya Sokarak, Birleştirerek Sıralama). Doğru Algoritma Seçimi Veri Büyüklüğüne Ve Amaçlara Göre Yapılmalı."},"NarrationText":"Sıralama algoritmaları zaman karmaşıklığı ve istikrarlılık açısından karşılaştırılır. Baloncuk, seçmeli ve araya sokarak sıralama genellikle O(n²) karmaşıklığa, hızlı, birleştirerek ve yığın sıralaması ise O(n log n) karmaşıklığa sahiptir. Ayrıca istikrarlı algoritmalar, aynı değere sahip elemanların sırasını korur; baloncuk, araya sokarak ve birleştirerek sıralama bu açıdan avantajlıdır. Doğru algoritma seçimi veri büyüklüğüne ve uygulama amacına göre yapılmalıdır.","Images":[{"ImagePrompt":"Table or infographic comparing sorting algorithms; highlight stability, time complexity (O(n²) vs O(n log n)), and scenarios for best use; include quoted points on algorithm strengths.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":33,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_42_2ce13902-37fb-4205-a456-d232d927e754.mp3","SpeechFileName":"AI_Section_42_2ce13902-37fb-4205-a456-d232d927e754.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":43,"Title":"Sıralama Algoritmalarında Uygulama ve Kodlama Prensipleri","Description":null,"Content":{"list":"Kodlama İçin İç İçe Döngüler Veya Özyinelemeli Fonksiyonlar Kullanılır; Karşılaştırma Ve Değiş Tokuş İşlemleri Temel İşlemlerdir; Büyük Veri Setleri İçin Hızlı, Birleştirerek Veya Yığın Sıralaması Tercih Edilmeli; Zaman Karmaşıklığı Performansı Doğrudan Etkiler"},"NarrationText":"Sıralama algoritmalarının kodlanması, genellikle iç içe döngülerle veya özyinelemeli fonksiyonlarla gerçekleştirilir. Dizinin elemanları üzerindeki karşılaştırma ve değiş tokuş işlemleri, algoritmanın temelini oluşturur. Büyük veri setlerinde hızlı sıralama, birleştirerek sıralama veya yığın sıralaması tercih edilmelidir. Seçilen algoritmanın zaman karmaşıklığı, uygulamanın genel performansında doğrudan etkili olur.","Images":[{"ImagePrompt":"Illustration showing code snippets of sorting algorithms: nested loops and recursion, list comparison and swaps, arrows representing efficiency in handling large datasets; performance charts embedded.","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":27,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_43_05f3046c-94d7-4b67-8d2a-9d14c28d0676.mp3","SpeechFileName":"AI_Section_43_05f3046c-94d7-4b67-8d2a-9d14c28d0676.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":44,"Title":"Çizge Kuramı: Temel Kavramlar ve Çizge Türleri","Description":null,"Content":{"list":"Çizge, Düğümler Ve Kenarlardan Oluşan Veri Yapısıdır; Yönlü Ve Yönsüz Çizgeler; Komşuluk Matrisi İlişkileri Gösterir; Ağırlıklandırılmış Çizgelerde Maliyet Ve Mesafe Bilgisi"},"NarrationText":"Çizge, düğümler ve bunları bağlayan kenarlardan oluşan veri yapısıdır. Çizgeler, yönlü ve yönsüz olarak ikiye ayrılır; yönlü çizgede kenarların bir yönü varken, yönsüz çizgede iki yön de kullanılabilir. Komşuluk matrisi çizge içindeki ilişkileri tablolarla gösterir. Ağırlıklandırılmış çizgelerde, kenarlar üzerinde mesafeyi veya maliyeti belirten sayılar bulunur. Çizge yapısı, sosyal ağlar, ulaşım ve bilgisayar ağları gibi birçok alanda uygulama bulur.","Images":[{"ImagePrompt":"Graph with colored nodes and edges, showing both directed and undirected edges, adjacency matrix table, and some edges labeled with weights","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":31,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_44_a682f502-4341-45d3-82eb-0ee372b4c54d.mp3","SpeechFileName":"AI_Section_44_a682f502-4341-45d3-82eb-0ee372b4c54d.mp3","RelevantDocumentPart":null},{"PageStyle":8,"YoutubeSearchKeyword":null,"Index":45,"Title":"Komşuluk Matrisi ve Çizgelerde Temel İlişkiler","Description":null,"Content":{"paragraph1":"Komşuluk Matrisi, Çizgedeki Düğümlerin Bağlantılarını Gösteren Tablo Olarak Kullanılır.","paragraph2":"Ağırlıklandırılmış Çizgelerde Kenarların Sayısal Değerleri Tabloya Yazılır Ve Algoritma Uygulamalarını Kolaylaştırır."},"NarrationText":"Komşuluk matrisi, çizgedeki düğümler arasındaki kenar bağlantılarını gösteren bir tablodur. Matriste, komşu düğümler için 1, bağlantı yoksa 0 değeri kullanılır. Ağırlıklandırılmış çizgelerde ise doğrudan kenar üzerindeki sayısal değerler tabloya yazılır. Komşuluk ve çakışım kavramları, çizge üzerindeki düğüm ve kenar ilişkilerini anlamaya yardımcı olur. Komşuluk matrisi, algoritmaların bilgisayar ortamında uygulanabilmesini kolaylaştırır.","Images":[{"ImagePrompt":"Simplified adjacency matrix table for a small graph, numbers 0, 1, and weight values clearly visible, highlighted connected nodes","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":29,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_45_de8415f4-c785-484c-af2b-5f9d9934d490.mp3","SpeechFileName":"AI_Section_45_de8415f4-c785-484c-af2b-5f9d9934d490.mp3","RelevantDocumentPart":null},{"PageStyle":33,"YoutubeSearchKeyword":null,"Index":46,"Title":"Çizgelerde Enine Arama (BFS) Algoritması","Description":null,"Content":{"title":"Çizgelerde Enine Arama (BFS) Algoritması","paragraph":"Enine arama algoritması bir düğümden başlayıp önce yakın komşuları sonra uzak komşuları ziyaret eder ve kuyruk veri yapısı kullanılır.","subtitle":"Kuyruk Kullanılır","subtext":"Her Düğüm Sırayla Ziyaret Edilir."},"NarrationText":"Enine arama algoritması (Breadth-First Search - BFS), çizgedeki bir düğümden başlayarak önce yakın komşuları, ardından uzak komşuları ziyaret ederek ilerler. Kuyruk (queue) veri yapısı kullanılır. Her düğüm sırasıyla kuyruğa eklenip işlenir, tüm düğümler sırayla ziyaret edilir. Enine arama algoritması bağlantılılığı kontrol etmek, kısayol bulmak ve çizge üstünde gezinme işlemlerinde etkili bir yöntemdir.","Images":[{"ImagePrompt":"Breadth-first search BFS graph traversal visual, nodes being explored level by level, showing queue data structure","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null},{"ImagePrompt":"Queue data structure illustration, connected graph nodes being added and processed in sequence","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":27,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_46_2a304e1c-c0c1-4aee-b17f-780c4a0d4284.mp3","SpeechFileName":"AI_Section_46_2a304e1c-c0c1-4aee-b17f-780c4a0d4284.mp3","RelevantDocumentPart":null},{"PageStyle":27,"YoutubeSearchKeyword":null,"Index":47,"Title":"Çizgelerde Önce Derinliğine Arama (DFS) Algoritması","Description":null,"Content":{"paragraph":"Önce derinliğine arama algoritması bir düğümden başlanarak en derin noktaya kadar ilerleyip geri dönerek çizgedeki tüm düğümleri dolaşır ve yığın veri yapısı kullanılır.","subtext1":"Yol Takibi Ve Alt Küme Bulma","subtext2":"Devre Çözümleme İçin Sık Kullanılır"},"NarrationText":"Önce derinliğine arama algoritması (Depth-First Search - DFS), bir düğümden başlanarak komşusu olan en derin noktaya kadar gidip geri dönerek tüm düğümleri dolaşır. Yığın (stack) veri yapısı kullanılır ve her adımda en derine inilene kadar ilerlenir. Bu algoritma, çizge üzerinde bağlantılı alt kümeleri bulma, yol sorgulama veya devre çözümlemesi gibi uygulamalarda sıklıkla tercih edilir ve yol takibi gerektiren sorunlarda etkilidir.","Images":[{"ImagePrompt":"Depth-first search DFS graph traversal, path traced deep into a graph, clear stack data structure illustration","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":29,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_47_4b27da38-ea89-49f3-961b-d8dd8817ff64.mp3","SpeechFileName":"AI_Section_47_4b27da38-ea89-49f3-961b-d8dd8817ff64.mp3","RelevantDocumentPart":null},{"PageStyle":28,"YoutubeSearchKeyword":null,"Index":48,"Title":"Dijkstra En Kısa Yol Algoritması: Temel Mantık","Description":null,"Content":{"list":"Dijkstra Algoritması Kısa Yol Bulmak İçin Kullanılır; Tüm Düğümlere Mesafe Başta Sonsuz Kabul Edilir; Adım Adım En Kısa Mesafe Güncellenir; Pratikte Maliyet Ve Erişim Süresini Hesaplama"},"NarrationText":"Dijkstra algoritması ağırlıklandırılmış çizgelerde, bir düğümden diğerlerine olan en kısa yolu bulmak için kullanılır. Başlangıçta tüm düğümlere olan mesafe sonsuz kabul edilir, algoritma adım adım en kısa yolları günceller. Her adımda en kısa mesafeye sahip yeni bir düğüm işaretlenir ve tüm komşuları için mesafe güncellenir. Pratikte en kısa rotaları, maliyetleri veya erişim süresini hesaplamada kullanılır.","Images":[{"ImagePrompt":"Graph with nodes and weighted edges, shortest path highlighted, numbers representing costs or distances, Dijkstra algorithm visual cues","ImageSize":"W1024xH1792","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_48_05f82dd7-a30c-4db1-b61d-2211483457ee.mp3","SpeechFileName":"AI_Section_48_05f82dd7-a30c-4db1-b61d-2211483457ee.mp3","RelevantDocumentPart":null},{"PageStyle":4,"YoutubeSearchKeyword":null,"Index":49,"Title":"Çizge Algoritmalarında Kodlama ve Uygulama Prensipleri","Description":null,"Content":{"paragraph":"Çizge algoritmaları uygun veri yapılarıyla programlamada kullanılır. BFS için kuyruk, DFS için yığın ve Dijkstra için mesafe ile önceki düğüm tabloları gerekir.","list":"Komşuluk Matrisi Kullanımı; Kuyruk Ve Yığın Veri Yapıları; Mesafe Tablosu Tasarımı; Büyük Çizgelerde Hızlı Analiz"},"NarrationText":"Çizge algoritmaları, komşuluk matrisi ve uygun veri yapıları ile programlamada kolayca kullanılabilir. Enine arama için kuyruk, derinlik arama için yığın yapısı kurulmalıdır. Dijkstra algoritmasında ise düğümler arası mesafeleri ve önceki düğümleri saklamak için ek diziler ya da tablolar gerekir. Kodların doğru tasarımı, büyük çizgelerde hızlı ve güvenilir analiz yapma imkanı sunar.","Images":[{"ImagePrompt":"Abstract computer code for graph algorithms, showing adjacency matrix, queue, stack, and shortest path tables, visually organized and educational","ImageSize":"W1792xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":25,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_49_7889089b-1949-45db-8efc-504d4f176129.mp3","SpeechFileName":"AI_Section_49_7889089b-1949-45db-8efc-504d4f176129.mp3","RelevantDocumentPart":null},{"PageStyle":2,"YoutubeSearchKeyword":null,"Index":50,"Title":"Eğitimin Sonu: Temel Çıkarımlar ve Genel Özet","Description":null,"Content":{"subtitle":"Temel Bilgiler ve Çıkarımlar","paragraph1":"Algoritma Kavramı ve Temel Türler Ele Alındı","paragraph2":"Doğru Veri Yapısı ve Etkin Algoritma Seçimi Performansı Belirler"},"NarrationText":"Bu eğitim boyunca, algoritma kavramı ve temel türleri, çeşitli veri yapıları, ağaçlar, özetleme tabloları, algoritma tasarım ve analiz süreçleri, temel arama ve sıralama algoritmaları ile çizge teorisinin önemli algoritmaları detaylı biçimde ele alındı. Yapıların avantajları, kullanımları ve karşılaştırmaları örneklerle aktarıldı. Etkin algoritmalar ve doğru veri yapısı seçimi, problem çözümünün performansını belirleyen başlıca unsur olarak öne çıktı.","Images":[{"ImagePrompt":"A group of people gathered around a digital whiteboard showing diagrams of algorithms, data structures, and graphs, representing summary and key insights from an educational course; bright, collaborative classroom atmosphere.","ImageSize":"W1024xH1024","ImageUrl":"https://aidea.elearningsolutions.net/IdealStudioEditor/images/placeholder.png","IsSuccess":false,"ErrorMessage":null}],"YoutubeUrl":null,"AudioDuration":28,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_50_ff40d43a-b6a5-44e3-8585-b6406022e5b5.mp3","SpeechFileName":"AI_Section_50_ff40d43a-b6a5-44e3-8585-b6406022e5b5.mp3","RelevantDocumentPart":null},{"PageStyle":11,"YoutubeSearchKeyword":"Algoritmalar ve Programlama: Kavramlardan Çizge Algoritmalarına","Index":11,"Title":"Algoritmalar ve Programlama: Kavramlardan Çizge Algoritmalarına","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":"https://www.youtube.com/watch?v=xoqQKFtfzvM","AudioDuration":0,"SpeechAudioUrl":null,"SpeechFileName":null,"RelevantDocumentPart":null},{"PageStyle":12,"YoutubeSearchKeyword":null,"Index":51,"Title":"Question 1","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":7,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-51_ai_Questione84e9ee3-cdfd-4758-912d-b67fe32ae463.mp3","SpeechFileName":"1-51_ai_Questione84e9ee3-cdfd-4758-912d-b67fe32ae463.mp3","RelevantDocumentPart":null},{"PageStyle":13,"YoutubeSearchKeyword":null,"Index":52,"Title":"Question 2","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":5,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-52_ai_Question46971867-326c-4dcc-b39f-d002a1b79571.mp3","SpeechFileName":"1-52_ai_Question46971867-326c-4dcc-b39f-d002a1b79571.mp3","RelevantDocumentPart":null},{"PageStyle":14,"YoutubeSearchKeyword":null,"Index":53,"Title":"Question 3","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":4,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-53_ai_Questiond95aeed4-410e-4376-a477-7e91804282d9.mp3","SpeechFileName":"1-53_ai_Questiond95aeed4-410e-4376-a477-7e91804282d9.mp3","RelevantDocumentPart":null},{"PageStyle":12,"YoutubeSearchKeyword":null,"Index":54,"Title":"Question 4","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":7,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-54_ai_Question991a79da-078d-4f89-8328-13928096dd07.mp3","SpeechFileName":"1-54_ai_Question991a79da-078d-4f89-8328-13928096dd07.mp3","RelevantDocumentPart":null},{"PageStyle":13,"YoutubeSearchKeyword":null,"Index":55,"Title":"Question 5","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":4,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-55_ai_Question7df288d4-10bc-4a13-8213-95ec7c24dfaf.mp3","SpeechFileName":"1-55_ai_Question7df288d4-10bc-4a13-8213-95ec7c24dfaf.mp3","RelevantDocumentPart":null},{"PageStyle":14,"YoutubeSearchKeyword":null,"Index":56,"Title":"Question 6","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":4,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-56_ai_Questionb1860ae5-968d-46d4-807c-9226c6da10a6.mp3","SpeechFileName":"1-56_ai_Questionb1860ae5-968d-46d4-807c-9226c6da10a6.mp3","RelevantDocumentPart":null},{"PageStyle":12,"YoutubeSearchKeyword":null,"Index":57,"Title":"Question 7","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":5,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-57_ai_Question8b4e54df-3bf1-4478-a393-8d386bc81eb8.mp3","SpeechFileName":"1-57_ai_Question8b4e54df-3bf1-4478-a393-8d386bc81eb8.mp3","RelevantDocumentPart":null},{"PageStyle":13,"YoutubeSearchKeyword":null,"Index":58,"Title":"Question 8","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":5,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-58_ai_Question6161239a-9bbe-4a0b-bd5b-602793a6b352.mp3","SpeechFileName":"1-58_ai_Question6161239a-9bbe-4a0b-bd5b-602793a6b352.mp3","RelevantDocumentPart":null},{"PageStyle":14,"YoutubeSearchKeyword":null,"Index":59,"Title":"Question 9","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":4,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-59_ai_Question6f50dbc1-b9af-455e-9b53-8a69c623be6b.mp3","SpeechFileName":"1-59_ai_Question6f50dbc1-b9af-455e-9b53-8a69c623be6b.mp3","RelevantDocumentPart":null},{"PageStyle":12,"YoutubeSearchKeyword":null,"Index":60,"Title":"Question 10","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":6,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-60_ai_Questionca0f484a-2fda-41c6-8537-0a86f9f2132d.mp3","SpeechFileName":"1-60_ai_Questionca0f484a-2fda-41c6-8537-0a86f9f2132d.mp3","RelevantDocumentPart":null},{"PageStyle":13,"YoutubeSearchKeyword":null,"Index":61,"Title":"Question 11","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":5,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-61_ai_Questiondcb34aa9-4bdc-4fb1-963c-265eb1538759.mp3","SpeechFileName":"1-61_ai_Questiondcb34aa9-4bdc-4fb1-963c-265eb1538759.mp3","RelevantDocumentPart":null},{"PageStyle":14,"YoutubeSearchKeyword":null,"Index":62,"Title":"Question 12","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":4,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-62_ai_Question79c9ecef-a198-4760-80df-00c919974b2f.mp3","SpeechFileName":"1-62_ai_Question79c9ecef-a198-4760-80df-00c919974b2f.mp3","RelevantDocumentPart":null},{"PageStyle":12,"YoutubeSearchKeyword":null,"Index":63,"Title":"Question 13","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":5,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-63_ai_Questionab5ce9e9-a5bf-4f1c-9a66-f619cfb90db9.mp3","SpeechFileName":"1-63_ai_Questionab5ce9e9-a5bf-4f1c-9a66-f619cfb90db9.mp3","RelevantDocumentPart":null},{"PageStyle":13,"YoutubeSearchKeyword":null,"Index":64,"Title":"Question 14","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":8,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-64_ai_Question7b956092-2e63-488a-85cb-ce0410b6d687.mp3","SpeechFileName":"1-64_ai_Question7b956092-2e63-488a-85cb-ce0410b6d687.mp3","RelevantDocumentPart":null},{"PageStyle":14,"YoutubeSearchKeyword":null,"Index":65,"Title":"Question 15","Description":null,"Content":null,"NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":4,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/1-65_ai_Question020ba184-5b8b-4b7e-a0fc-c10c831b5696.mp3","SpeechFileName":"1-65_ai_Question020ba184-5b8b-4b7e-a0fc-c10c831b5696.mp3","RelevantDocumentPart":null},{"PageStyle":100,"YoutubeSearchKeyword":null,"Index":100,"Title":"Şimdi Sıra Sizde","Description":null,"Content":"Tebrikler, Eğitimi Tamamladınız","NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":2,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_100_1cdcabe6-8c27-4d51-80f8-9db5a81324a5.mp3","SpeechFileName":"AI_Section_100_1cdcabe6-8c27-4d51-80f8-9db5a81324a5.mp3","RelevantDocumentPart":null},{"PageStyle":101,"YoutubeSearchKeyword":null,"Index":101,"Title":"Tebrikler, Eğitimi Tamamladınız","Description":null,"Content":"Tebrikler, Eğitimi Tamamladınız","NarrationText":null,"Images":null,"YoutubeUrl":null,"AudioDuration":3,"SpeechAudioUrl":"https://aidea.elearningsolutions.net/ContentFiles/IdealStudioFiles/AI_Section_101_2df7ee48-6087-43ae-804d-5f3dc2e84ed7.mp3","SpeechFileName":"AI_Section_101_2df7ee48-6087-43ae-804d-5f3dc2e84ed7.mp3","RelevantDocumentPart":null}],"GeneralQuiz":[{"Index":51,"Type":0,"Question":"Algoritma analizinde zaman karmaşıklığını gösteren büyük O notasyonu aşağıdakilerden hangisini tanımlar?","Options":["Algoritmanın en iyi sonucu verdiği alt sınırı","Algoritmanın en kötü durumda büyüme üst sınırını","Algoritmanın bellekte kapladığı alanı","Algoritmanın ortalama verimliliğini"],"CorrectAnswers":["Algoritmanın en kötü durumda büyüme üst sınırını"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":52,"Type":1,"Question":"Aşağıdakilerden hangileri istikrarlı (stable) sıralama algoritmalarıdır?","Options":["Baloncuk Sıralama","Seçmeli Sıralama","Birleştirerek Sıralama","Yığın Sıralama"],"CorrectAnswers":["Baloncuk Sıralama","Birleştirerek Sıralama"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":53,"Type":2,"Question":"Aşağıdaki ifadelerin Doğru mu Yanlış mı olduğuna karar verin","Options":null,"CorrectAnswers":null,"Statements":[{"Statement":"Bağlı listeler dinamik uzunluğa sahip veri yapılarıdır.","Answer":"True"},{"Statement":"AVL ağaçlarında denge bozulunca döndürme işlemi uygulanmaz.","Answer":"False"},{"Statement":"Kuyruk veri yapısı LIFO prensibiyle çalışır.","Answer":"False"},{"Statement":"Hash tabloları, büyük veri kümelerinde hızlı arama sağlar.","Answer":"True"}],"IsSuccess":true,"ErrorMessage":null},{"Index":54,"Type":0,"Question":"Aşağıdakilerden hangisi çizge algoritmalarında enine arama (BFS) algoritmasının temel özelliğidir?","Options":["Yığın veri yapısını kullanmak","Derinlere inmeden önce yakın komşuları ziyaret etmek","En kısa yolu her zaman bulmak","Sadece yönlü çizgelerde çalışmak"],"CorrectAnswers":["Derinlere inmeden önce yakın komşuları ziyaret etmek"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":55,"Type":1,"Question":"Aşağıdaki veri yapılarından hangileri hızlı erişim imkânı sunar?","Options":["Dizi (Array)","Bağlı Liste (Linked List)","Hash Tablosu (Hash Table)","Yığın Ağacı (Heap Tree)"],"CorrectAnswers":["Dizi (Array)","Hash Tablosu (Hash Table)"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":56,"Type":2,"Question":"Aşağıdaki ifadelerin Doğru mu Yanlış mı olduğuna karar verin","Options":null,"CorrectAnswers":null,"Statements":[{"Statement":"Yığın veri yapısı Son Giren İlk Çıkar (LIFO) prensibiyle çalışır.","Answer":"True"},{"Statement":"Dijkstra algoritması çizgelerde en kısa yolun bulunmasında kullanılır.","Answer":"True"},{"Statement":"Birleştirerek sıralama algoritması istikrarlı değildir.","Answer":"False"},{"Statement":"Ardışık arama algoritması yalnızca sıralı dizilerde kullanılabilir.","Answer":"False"}],"IsSuccess":true,"ErrorMessage":null},{"Index":57,"Type":0,"Question":"Aşağıdaki algoritmalardan hangisi yalnızca sıralı dizilerde doğru şekilde çalışır?","Options":["Ardışık arama","İkili arama","Baloncuk sıralama","Birleştirerek sıralama"],"CorrectAnswers":["İkili arama"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":58,"Type":1,"Question":"Aşağıdaki ifadelerden hangileri algoritmanın doğruluk analizinde gereklidir?","Options":["Tüm girdi değerleri için doğru sonuç üretildiğini kanıtlamak","Kodlama aşamasında hata ayıklama yapmak","Algoritmanın çalışma zamanını analiz etmek","Yanlış sonuç üreten örnekleri göstermek"],"CorrectAnswers":["Tüm girdi değerleri için doğru sonuç üretildiğini kanıtlamak","Yanlış sonuç üreten örnekleri göstermek"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":59,"Type":2,"Question":"Aşağıdaki ifadelerin Doğru mu Yanlış mı olduğuna karar verin","Options":null,"CorrectAnswers":null,"Statements":[{"Statement":"Dinamik programlama, problemi alt parçalara bölerek ve sonuçları saklayarak çözmeyi sağlar.","Answer":"True"},{"Statement":"Seçmeli sıralama algoritmasının zaman karmaşıklığı O(n log n)‘dir.","Answer":"False"},{"Statement":"Çizge algoritmalarında BFS için kuyruk ve DFS için yığın veri yapısı kullanılır.","Answer":"True"},{"Statement":"Hash fonksiyonlarında çatışma hiç oluşmaz.","Answer":"False"}],"IsSuccess":true,"ErrorMessage":null},{"Index":60,"Type":0,"Question":"Aşağıdakilerden hangisi özyinelemeli fonksiyon algoritmalarının en belirgin özelliğidir?","Options":["İşlemlerin sıralı olarak yapılması","Fonksiyonun kendini tekrar çağırması","Veri üzerinde doğrusal arama yapılması","Bellek kullanımının sabit tutulması"],"CorrectAnswers":["Fonksiyonun kendini tekrar çağırması"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":61,"Type":1,"Question":"Aşağıdaki algoritma türlerinden hangileri problemi alt parçalara ayırarak çözüm üretir?","Options":["Böl-Fethet (Divide &amp; Conquer)","Açgözlü (Greedy)","Dinamik Programlama","Geri İzlemeli (Backtracking)"],"CorrectAnswers":["Böl-Fethet (Divide &amp; Conquer)","Dinamik Programlama"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":62,"Type":2,"Question":"Aşağıdaki ifadelerin Doğru mu Yanlış mı olduğuna karar verin","Options":null,"CorrectAnswers":null,"Statements":[{"Statement":"Kuyruk veri yapısında veriler son noktadan eklenip baştan çıkarılır.","Answer":"True"},{"Statement":"Yığın ağaçlarında en büyük değer her zaman kök düğümde yer alır.","Answer":"False"},{"Statement":"Algoritmanın gösterimi akış şeması ile yalnızca görsel değil, kodlama için de kullanılabilir.","Answer":"True"},{"Statement":"Komşuluk matrisi çizgedeki tüm düğümlerin komşuluk derecesini göstermez.","Answer":"False"}],"IsSuccess":true,"ErrorMessage":null},{"Index":63,"Type":0,"Question":"Aşağıdakilerden hangisi bir bağlı listenin temel avantajlarından biridir?","Options":["Sabit uzunlukta veri saklama","Doğrudan hızlı erişim","Kolay ekleme ve silme işlemleri","Yalnızca tek boyutlu veri desteği"],"CorrectAnswers":["Kolay ekleme ve silme işlemleri"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":64,"Type":1,"Question":"Aşağıdaki ifadelerden hangileri sıralama algoritmalarında zaman karmaşıklığı O(n log n) olan algoritma türlerindendir?","Options":["Birleştirerek sıralama","Hızlı sıralama (Quick Sort)","Baloncuk sıralama","Seçmeli sıralama"],"CorrectAnswers":["Birleştirerek sıralama","Hızlı sıralama (Quick Sort)"],"Statements":null,"IsSuccess":true,"ErrorMessage":null},{"Index":65,"Type":2,"Question":"Aşağıdaki ifadelerin Doğru mu Yanlış mı olduğuna karar verin","Options":null,"CorrectAnswers":null,"Statements":[{"Statement":"Ağaçlarda ikili arama ağacında sol çocuk her zaman büyük değere sahiptir.","Answer":"False"},{"Statement":"Algoritma tasarımında doğruluk analizi kodlama öncesi yapılmalıdır.","Answer":"True"},{"Statement":"Dizilerde elemanlar indislerle erişilir.","Answer":"True"},{"Statement":"Kaba kuvvet algoritmaları yalnızca dinamik programlama problemlerinde kullanılır.","Answer":"False"}],"IsSuccess":true,"ErrorMessage":null}],"IsSuccess":true,"ErrorMessage":null,"ErrorCode":0,"ThreadId":null,"FullDocumentText":null,"SummaryDocumentText":null}